{"meta":{"title":"suite.lab 기술 블로그","subtitle":"윤옴므의 기술 블로그.","description":"윤옴므의 기술 블로그. 개발자로 성장하며 익힌 기술과 경험, 지식을 공유합니다.","author":"Woosik Yoon","url":"http://suitee.me"},"pages":[{"title":"About","date":"2018-10-31T02:09:17.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"about/index.html","permalink":"http://suitee.me/about/index.html","excerpt":"","text":"안녕하세요. 윤우식입니다.글재주는 없지만 개발을 좋아하고 기술적 경험을 공유하는 것을 즐겨합니다. 그래서 이 블로그를 통해 더 많은 사람들과 나누고 배우고자 합니다. 블로그는 일상적인 이야기, 오늘 공부하거나 얻은 지식들, 새롭게 배우고 싶은 기술 등등 여러가지 포스트로 채워갈 생각입니다. 잘못된 내용이나 부자연스러운 문장, 오타, 맞춤법은 댓글로 지적해주시면 감사드리겠습니다. 소통도 환영합니다. 기술에 관련된 이야기나 관련되지 않은 내용도 환영합니다. 스팸만 아니라면 email : woosiks.io@gmail.com 경험해본 기술들 Category Techs Languages - Python - C# - MS SQL Frameworks - Django - Tensorflow - Keras - .net framework Tools - Visual Studio - PyCharm - AWS - Google Cloud Console - SQL Server Management Studio SCM - Git - Source Safe - Team Foundation Server 공부할 기술들 Category Techs Languages - JAVA - JavaScript - HTML5 Frameworks - Spring - Django(고급 활용) Tools - Eclipse - IntelliJ IDEA SCM - Git(고급 활용)"}],"posts":[{"title":"무료로 내 블로그에 SSL[HTTPS] 적용하기 - 2","slug":"how-to-setup-free-ssl-2","date":"2019-02-14T01:00:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2019/02/14/how-to-setup-free-ssl-2/","link":"","permalink":"http://suitee.me/2019/02/14/how-to-setup-free-ssl-2/","excerpt":"","text":"이전글 : 무료로 내 블로그에 SSL[HTTPS] 적용하기 이전글에 작성한 것 처럼 Github Pages 블로그에 Cloudflare를 적용하여 이용하고 있었는데 국내에서 Cloudflare를 서비스에 이용하면 꽤 느려질 수 있다는 댓글을보고 필자의 블로그를 모니터링을 해보았는데 체감상 꽤나 느려짐이 느껴졌다. 이 글에서는 필자가 새롭게 블로그에 적용한 Github Pages 블로그 이용자를 위한 HTTPS 적용방법을 소개하려고 한다. HTTPS를 적용하기 전과 거의 차이없는 속도를 나타낸다. 선행 조건 커스텀 도메인 사용자여야한다. (github.io 도메인은 이미 https가 적용되고 있음) Cloudflare 등 HTTPS 서비스가 적용되고 있지 않아야한다. (블로그 주소가 http:// 로 시작되는 주소여야함) 1. 도메인 서비스에 레코드 추가godaddy와 같은 필자가 이용하는 커스텀 도메인 서버에서 DNS관리 메뉴에 들어간다.기존에 설정 되어있는 A 유형의 레코드의 값을 아래의 값들 중 하나로 변경 또는 추가 해준다. 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 필자는 185.199.108.153 를 사용하였다. bash에서 dig 명령어를 통해 레코드 적용여부를 확인 할 수 있다. 12345678910111213$ dig suitee.me +nostats +nocomments +nocmd; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.1-Ubuntu &lt;&lt;&gt;&gt; suitee.me +nostats +nocomments +nocmd;; global options: +cmd;suitee.me. IN Asuitee.me. 600 IN A 185.199.108.153$ dig suitelab.github.io +nostats +nocomments +nocmd; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.1-Ubuntu &lt;&lt;&gt;&gt; suitelab.github.io +nostats +nocomments +nocmd;; global options: +cmd;suitelab.github.io. IN Asuitelab.github.io. 600 IN A 185.199.108.153 dig 명령어에서 본인의 블로그 원본 주소 {username}.github.io 와 커스텀 도메인 example.com 의 ip 값(ex: 185.199.108.153)이 같으면 성공이다. 적용까지는 시간이 조금 걸리는 것 같다. (수십분 ~ 24시간) 2. 블로그의 Github Repository의 Settings 변경본인 블로그의 repo의 설정으로 이동한다. Github Pages 항목에서 Enforce HTTPS 항목을 체크한다. 그리고 Custom domain 칸의 도메인 주소를 지우고 Save 새로고침 후 도메인 주소를 채우고 Save 한다.domain을 삭제 및 저장해야 DNS 변경사항이 반영된다고 한다. Your site is published at https://example.com/라는 메시지가 보이면 성공이다!이 또한 적용까지는 시간이 조금 걸리는 것 같다. (수십분 ~ 24시간) 3. 결과 확인아름다운 초록색 자물쇠와 함께 Let’s Encrypt 인증서가 보인다. 4. 기타 확인할 사항들글이 길어질 것 같아 다루지 않은 사항들이다. 필요시 검색을 통해 설정해두면 좋을 것 같다. Google Search Console에서 https 추가 Google Analytics https설정 기타 https로 전환했을 시 변경해아 할 것들","categories":[{"name":"Blog","slug":"Blog","permalink":"http://suitee.me/categories/Blog/"}],"tags":[{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"http://suitee.me/tags/GitHub-Pages/"},{"name":"SSL","slug":"SSL","permalink":"http://suitee.me/tags/SSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://suitee.me/tags/HTTPS/"}]},{"title":"무료로 내 블로그에 SSL[HTTPS] 적용하기","slug":"how-to-setup-free-ssl","date":"2019-02-13T03:00:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2019/02/13/how-to-setup-free-ssl/","link":"","permalink":"http://suitee.me/2019/02/13/how-to-setup-free-ssl/","excerpt":"","text":"모니터링해본 결과 Github pages를 이용한 블로그는 아래의 방법으로 이용하는 것이 편하고 빠르고 수월할 것이라고 생각한다. 본인의 블로그도 아래의 방법으로 변경하였다. 무료로 내 블로그에 SSL[HTTPS] 적용하기 - 2 Github pages 블로그를 운영하면서 커스텀 도메인(suitee.me)을 사용하고 있었다.오늘 웹서핑중에 우연찮게 무료로 SSL을 제공해준다는 서비스를 발견해서 냉큼 사용해보았다.결과는 성공적이었다.github.io에서 지원하던 https를 커스텀 도메인에도 “무료”로 사용할 수 있는 방법을 찾아서 소개해보고자 한다. 1. Cloudflare 가입하기주소: https://www.cloudflare.com/ko-kr/우선 Cloudflare 서비스에 가입한다.가입방법은 간단하다. 이메일 인증등 일련의 과정을 거치고나서 Plan선택화면이 나온다.우리는 무료 서비스를 이용할 것이기 때문에 FREE를 선택해준다. 본인의 블로그 주소를 입력한 뒤 (ex:suitee.me) 기존에 설정된 dns 레코드들을 확인할 수 있다.Continue를 눌러준다. 2. Nameserver 설정하기커스텀 도메인을 구입(관리) 한 사이트로 가서 네임서버를 바꿔주어야 한다.해당 사이트로 가서 설정되어있는 도메인(From)을 (TO)로 변경해주면 된다.본인의 경우 고대디에서 구매했다. (.me 도메인이 제일 저렴한 곳이었어서 선택했다.) 기존에 설정되어있는 네임서버를 다음과 같이 설정한다. 아까 복사해둔 To칸의 주소들을 붙여넣어준다. 설정이 완료되면 다음과 같이 표시된다. 메일로도 확인메일이 띠링 하고 날라온다. 3. HTTP-&gt;HTTPS Redirect 설정하기마지막으로 Crypto메뉴에서 Always Use HTTPS 항목을 On으로 설정해준다.example.com 로 접속해도 자동으로 https://example.com 으로 Redirect 해주는 기능이다. 4. 결과확인모든 일들이 순탄하게 해결됐다면 시간이 조금 지난 후에 정상적으로 반영이 된 것을 확인할 수 있다.반영에는 최대 24시간까지 걸릴 수 있다고한다. 본인은 15분정도 소요된 것 같다.아름다운 초록색 자물쇠가 당신을 반겨줄 것이다. 5. 기타 확인할 사항들글이 길어질 것 같아 다루지 않은 사항들이다. 필요시 검색을 통해 설정해두면 좋을 것 같다. Google Search Console에서 https 추가 Google Analytics https설정 기타 https로 전환했을 시 변경해아 할 것들","categories":[{"name":"Blog","slug":"Blog","permalink":"http://suitee.me/categories/Blog/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"http://suitee.me/tags/SSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://suitee.me/tags/HTTPS/"}]},{"title":"simple resume[이력서 생성기] 개발기","slug":"simple-resume","date":"2018-12-17T01:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/12/17/simple-resume/","link":"","permalink":"http://suitee.me/2018/12/17/simple-resume/","excerpt":"","text":"Demo 링크 : http://resume.suitee.me/Github 링크 : https://github.com/suitelab/simple-resume 이직을 준비하며 지난 주말에 문득 생각이 들었다. “이력서 생성기를 만들어볼까?”MS Word로 작성해둔 나름 이쁘게 디자인했다고 생각되는 이력서가 하나 있다. 하지만 여간 귀찮은 부분이 한두가지가 아니다.다른 작성 환경에서 이력서 작성시 사용한 폰트도 새로 다운받아 줘야하고 양식을 변경하거나 이력 등을 추가할때 틀을 유지시키려고 할 때 신경써줘야할 부분이 많다. (물론 MS Word에 익숙하지 않은 탓도 있다.) 이런 저러한 이유로 현재 이 블로그의 정적 웹페이지 생성기에서 영감을 얻은 이력서 생성기가 만들고 싶어졌다. 요즘 한창 node.js를 공부하고 있기 때문에 node.js로 구현하고 싶었다.기능은 다음과 같이 간단하게 생각해보았다. express 서버로 개발할 것. yaml파일로 작성하여 폰트 등등 사용자가 신경쓸부분을 줄이기. 경력사항등 항목들을 자유자재로 커스텀마이징 할 수 있을 것. pdf 변환기능을 제공할 것. 우선 이력서 디자인은 프론트엔드 분야와 썩 친하지 않기때문에 굉장히 깔끔하고 직관적이라고 생각이 든 https://hyunseob.github.io/resume/ 에서 많은 부분 참고를 하였다. 심지어 코드마저 깔끔하다.이현섭님 감사드립니다! express 서버로 개발할 것.사실 node.js를 사용하겠다고 했지만 막상 사용한 부분은 서버 구동과 pdf변환 정도로만 사용한 것 같다. 심지어 route도 없다.(simple is best 👍) html쪽은 생산성이 좋은 템플릿 엔진 ejs를 사용하였고 구조는 다음과 같이 section 별로 나누었다.현재 education과 license의 양식이 거의 동일하기 때문에 합치는게 좋을지 유지할지 고민중이다. yaml파일로 작성하여 폰트 등등 사용자가 신경쓸부분을 줄이기. 이력서 작성은 yaml을 사용함으로써 작성할때 광장히 직관적이고 편리하다.물론 작성항목들도 최대한 직관적으로 구성해보았다. 그리고 각 카테고리마다 이모지도 달아서 좀 더 눈에 잘 들어오게 하였다. 경력사항등 항목들을 자유자재로 커스텀마이징 할 수 있을 것.구조가 저렇기 때문에 유저가 원하는 입맛대로 항목들을 추가, 삭제할 수 있는 장점이 있다. 예를들어 license 항목이 필요없는 사용자의 경우 yml에서 license 부분을 주석처리하면 끝이다.반대로 항목을 추가하고 싶은 사용자는 ejs파일과 yml에서 항목을 추가해서 사용하면 된다! pdf 변환기능을 제공할 것.이부분 고민을 많이 하였다. 이력서는 요새 pdf로 제출하는 것이 트렌드라서 pdf로 변환해주는 기능이 필요하다고 생각되었다.사실 브라우저에서 pdf로 출력 기능을 제공하기 때문에 그렇게 이용하고 싶은 사람은 저 방법대로 해도 좋다!pdf출력 기능을 검색하던 중 npm 패키지인 puppeteer라는 Google Chrome에서 만든 패키지가 있었다. chrome에서 pdf로 출력하는 기능을 puppeteer에서 그대로 메서드로 제공하고 있어서 쉽게 pdf로 변환할 수 있게되었다.pdf 변환기능은 npm run pdf {path/to/file/name} 의 명령어로 사용할 수 있다.파라미터에 원하는 경로/파일이름 으로 입력하면 해당 경로에 pdf파일로 저장하게 된다. 원래 본인이 쓰려고 만든 서비스지만 커스텀 이력서를 작성하고 싶은 많은 분들께 도움이 되고 싶어서 오픈소스로 공개하게 되었다. 개인이 만든 서비스이기 때문에 불편한점이나 버그가 있을 수 있다.https://github.com/suitelab/simple-resume 에서 Issues, Pull requests를 받고 있으니 자유롭게 작성해주시면 서비스 개선에 도움이 될 것 같다. 글과 서비스가 도움이 되셨다면 repository의 ⭐(Star) 많이 눌러주세요! 🛴","categories":[{"name":"Web","slug":"Web","permalink":"http://suitee.me/categories/Web/"},{"name":"Node.js","slug":"Web/Node-js","permalink":"http://suitee.me/categories/Web/Node-js/"}],"tags":[{"name":"YAML","slug":"YAML","permalink":"http://suitee.me/tags/YAML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://suitee.me/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://suitee.me/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://suitee.me/tags/HTML/"},{"name":"Express","slug":"Express","permalink":"http://suitee.me/tags/Express/"},{"name":"EJS","slug":"EJS","permalink":"http://suitee.me/tags/EJS/"}]},{"title":"vs code에서 File is a CommonJS module; 메시지 발생할 때.","slug":"file-is-a-commonjs-module","date":"2018-12-04T01:00:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2018/12/04/file-is-a-commonjs-module/","link":"","permalink":"http://suitee.me/2018/12/04/file-is-a-commonjs-module/","excerpt":"","text":"오늘은 미세먼지급 팁을 가져왔다. vs code로 node.js 개발을 하고있는데[js] File is a CommonJS module; it may be converted to an ES6 module. 라는 메시지가 나를 꽤나 성가시게 하였다. const http = require(&#39;http&#39;); require등을 사용할 때 발생하고 덕분에 require가 자동완성도 되지않는다. 해결방법 File &gt; Preferences &gt; Settings 또는 Ctrl + , 입력 후 아래 사진과 같이 suggestion Actions을 검색하고Javascript &gt; Suggestion Actions: Enabled 의 체크를 해제한다. 이후 더이상의 경고는 발생하지 않았다! 필자의 경우에는 성가심 해결이 먼저여서 우선 조치를 취했지만, 이 메세지에 관해서 자세히 알고 싶은 사람은 다음 vscode의 Issue를 들여다 보면 도움이 될 것 같다. [js] File is a CommonJS module; it may be converted to an ES6 module. #47299 🛴","categories":[{"name":"Web","slug":"Web","permalink":"http://suitee.me/categories/Web/"},{"name":"Node.js","slug":"Web/Node-js","permalink":"http://suitee.me/categories/Web/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://suitee.me/tags/Node-js/"},{"name":"editor","slug":"editor","permalink":"http://suitee.me/tags/editor/"},{"name":"vs code","slug":"vs-code","permalink":"http://suitee.me/tags/vs-code/"}]},{"title":"로스트아크 대기열 카카오톡 알림봇 개발기 - 2","slug":"lostark-wait-notifier-2","date":"2018-11-23T01:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/11/23/lostark-wait-notifier-2/","link":"","permalink":"http://suitee.me/2018/11/23/lostark-wait-notifier-2/","excerpt":"","text":"서비스 링크 : https://pf.kakao.com/_dcPGjGithub 링크 : https://github.com/suitelab/lostark-wait-notifier 기존 서비스가 loaq측의 요청으로 데이터를 크롤링할 수 없게 되었다.서비스가 주거버려따..서비스의 친구수는 점점 늘어가는데 제대로 운영하지 못해서 죄송스러울 따름이었고,이렇게 수요가 많은 서비스를 꼭 다시 운영해봐야겠다는 생각을 갖고있었다. 그래서 서비스를 중단하고 있는 와중에 https://rubystarashe.github.io/lostark/(이하 대기열서비스)를 운영하고 계신루비스타님이 데이터 수집을 혼쾌히 허락해주셔서 다시 운영할 수 있게 되었다. 개발 프로세스는 다음과 같이 구상하였다. 대기열 서비스의 데이터를 크롤링한다. 크롤링한 데이터를 가공하여 DB에 저장한다. 스케줄러를 사용한다. 사용자의 요청시 마다 DB에서 데이터를 kakao 플러스친구 api를 통해 서비스 한다. 1. 대기열서비스의 데이터를 크롤링한다.크롤러의 경우 selenium를 자주 써봤어서 고려해봤지만 브라우저를 사용하는 selenium 특성상 request당 매번 빠르게 크롤링 해야하는 이번 서비스에는 어울리지 않겠다는 생각이 들었다.라고 1편에 적었지만 대기열서비스가 렌더링을 통해 생성되기 때문에 일반적인 방법으로는 DOM구조를 수집할 수 없었다.그래서 selenium을 통해 브라우징을 하고 긁어온 DOM을 BeautifulSoup를 사용하여 처리했다. 바로 대기열서비스의 구조를 파악해보자. 데이터가 생성되기 전의 모습123456789&lt;body data-n-head=\"\"&gt; &lt;div id=\"__nuxt\"&gt; &lt;style&gt; #nuxt-loading &#123; visibility: hidden; opacity: 0; position: absolute; left: 0;... 데이터가 생성된 후의 모습123456789101112&lt;div id=\"__nuxt\"&gt;... &lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt; &lt;span class=\"data name\"&gt;안타레스&lt;/span&gt; &lt;span class=\"data queue\" style=\"opacity: 1; color: yellow;\"&gt;9590&lt;/span&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;span class=\"data name\"&gt;아크투르스&lt;/span&gt; &lt;span class=\"data queue\" style=\"opacity: 1; color: yellow;\"&gt;7839&lt;/span&gt; &lt;/div&gt;... 크롤링하기 좋게 구조가 짜여져있다.soup.select() 메서드로 span tag의 data name 태그를 불러오면 서버이름 리스트,data queue 태그를 불러오면 서버의 대기열 리스트를 가져올 수 있을 것이다.그러면 바로 구현해보자. 12345for i in range(server_count): server = soup.select('span.data.name')[i].text queue = soup.select('span.data.queue')[i].text items.append(&#123;\"server\": server, \"queue\": queue&#125;) 2. 크롤링한 데이터를 가공하여 DB에 저장한다.원래 DB까지 쓰고싶지 않았지만 selenium을 사용하게 되니 한번 크롤링하는데 평균 4.5초라는 시간이 걸렸다. 카톡봇에게 대기열 요청하고 약 5초간 기다리게 된다면 매우 끔찍할 것이다.그래서 구상한 생각은 selenium 브라우저를 띄워놓고 주기적으로 크롤링을 하여 DB로 저장하는 방법이었다. DB는 많이 쓰이는 MySql을 사용하였고 테이블 구조는 다음과 같다. server table에는 최초에 서버리스트를 저장해두고 크롤링 할때마다 queue table에 insert하게 하였다. 1234567def insert_queue_query(self, queues): for i, queue in enumerate(queues): sql_query = f\"INSERT INTO queue(date_time, server_id, queue) VALUES (now(), &#123;i + 1&#125;, &#123;queue['queue']&#125;);\" self.cursor.execute(sql_query) self.conn.commit() print('&#123;0&#125;개의 정보 업데이트 완료: &#123;1&#125;'.format(len(queues), str(datetime.now()))) 그리고 table에 시간당 약 10,000건의 데이터가 들어올 것으로 예상되어 퍼포먼스를 위해 데이터를 일정 주기마다 일부를 삭제하게 하였다.만약 통계등의 데이터를 제공하게 된다면 이부분은 다시 고려해봐야 할 것 같다. 123456789def delete_data(self): sql = \"\"\" DELETE FROM queue ORDER BY date_time ASC LIMIT 9000; \"\"\" self.cursor.execute(sql) self.conn.commit() print('9000개의 정보 삭제 완료: &#123;0&#125;'.format(str(datetime.now()))) Crawler class의 init부분에서 크롬드라이버가 실행되기 때문에 db에서 데이터를 제공할때 (느린)크롬드라이버를 실행할 필요는 없었다. DbTools class 객체를 생성할 때 select_only 파라미터를 둠으로써 조회만 사용할 객체의 경우 빠른 속도로 실행할 수 있게 하였다. 123456789101112class DbTools: def __init__(self, select_only = False): self.conn = pymysql.connect(host=config.DATABASE_CONFIG[\"host\"], user=config.DATABASE_CONFIG[\"user\"], db=config.DATABASE_CONFIG[\"db\"], password=config.DATABASE_CONFIG[\"password\"], charset=config.DATABASE_CONFIG[\"charset\"]) self.cursor = self.conn.cursor() self.crawler = None if not select_only: self.crawler = Crawler() 3. 스케줄러를 사용한다.스케줄러는 처음 써봤지만 사용법이 간단해보이는 schedule 모듈을 사용하였다.다음과 같은 짧은 코드로 스케줄러가 완성되었다. 서버와 별개로 백그라운드로 돌면서 2초마다 크롤링하고 4000초(약 1시간)마다 데이터를 9000건을 삭제하는 스케줄러가 된 것이다. 1234567891011121314151617# schedule.pydb = DbTools(select_only=False)def insert_schedule(): db.save_data()def delete_schedule(): db.delete_data()if __name__ == \"__main__\": print(\"scheduler is running! &#123;&#125;\".format(datetime.now())) schedule.every(2).seconds.do(insert_schedule) schedule.every(4000).seconds.do(delete_schedule) while True: schedule.run_pending() time.sleep(1) 4. 사용자의 요청시 마다 DB에서 데이터를 kakao 플러스친구 api를 통해 서비스 한다.kakao api 사용부분은 기존과 크게 변한게 없지만 message_button 파라미터를 추가해보았다.(물론 블로그 홍보라는 사리사욕을 채우기 위해서) 1data_send[\"message\"].update(&#123;'message_button': &#123;'label': '개발자 윤옴므 블로그', 'url': 'http://suitee.me'&#125;&#125;) 개발자 윤옴므 블로그 라는 버튼이 아주 잘 생성되었다. 5. 기타 server는 AWS EC2의 t3.micro 인스턴스로 Ubuntu를 사용하고 있다. GUI를 설치하지 않은 관계로 putty를 사용하고있는데 당연히 putty를 종료하면 putty로 실행하고 있던 프로그램은 종료가 된다.그래서 백그라운드를 돌리는 프로그램으로 원래 node.js용으로 npm에서 제공되는 forever를 사용하였다. 설치 후 해당 디렉토리에서 다음과 같이 명령어를 작성하면 python 서비스지만 아주 정상적으로 작동한다. 12$ forever start -c python3 kakao.py$ forever start -c python3 scheduler.py 로스트아크 점검공지사항을 보여주는 기능을 고려중이다. 빠른시일내에 서비스가 제공될 수도 있을것 같다. 섬시간 알림 기능도 고려중이다. 이번 주말부터 로스트아크가 서버를 대대적으로 증설한다고 한다. 울어야 할지 웃어야 할지… 내 서비스의 존폐 여부가 달려 있을듯 싶다. 물론 대기열이 없으면 더욱 행복할 것 같다 :) 🛴","categories":[{"name":"Web","slug":"Web","permalink":"http://suitee.me/categories/Web/"},{"name":"API","slug":"Web/API","permalink":"http://suitee.me/categories/Web/API/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"http://suitee.me/tags/Crawler/"},{"name":"API","slug":"API","permalink":"http://suitee.me/tags/API/"},{"name":"json","slug":"json","permalink":"http://suitee.me/tags/json/"},{"name":"Kakao plus friend","slug":"Kakao-plus-friend","permalink":"http://suitee.me/tags/Kakao-plus-friend/"}]},{"title":"로스트아크 대기열 카카오톡 알림봇 개발기","slug":"lostark-wait-notifier","date":"2018-11-18T01:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/11/18/lostark-wait-notifier/","link":"","permalink":"http://suitee.me/2018/11/18/lostark-wait-notifier/","excerpt":"","text":"서비스 링크 : https://pf.kakao.com/_dcPGjGithub 링크 : https://github.com/suitelab/lostark-wait-notifier 들어가기 전에http://loaq.kr/는 데이터 재배포를 금지하고 있습니다!이 게시물은 기존에 만들었던 서비스로써 현재의 운영방법이 아닙니다. 후기로만 봐주세요! 현재 운영중인 서비스의 개발 후기는http://suitee.me/2018/11/18/lostark-wait-notifier-2/에 올려두었습니다. 요즘 로스트아크를 재밌게 즐기고 있다.(포스팅이 뜸해지는 원흉) 하지만 좀처럼 줄어들지 않는 대기열때문에 평일 오후 5시, 주말 오전 10시 이후에는 대기열과의 전쟁을 치뤄야한다.필자가 플레이하는 서버인 알데바란 기준 평균 대기열은 15,000명 정도 되는 것 같다. 대략 시간을 재본 결과 2시간 넘게 대기를 하였다. http://loaq.kr/ 로스트아크를 즐겨하는 유저들의 경우 대기열 현황을 볼 수 있는 저 사이트를 꽤나 많이 알고있고 이용할 것이다. 물론 필자도 종종 이용하는 편이다. 매번 사이트에 주소를 치고 들어가 새로고침하는게 귀찮아지던 찰나에 카카오톡 플러스친구 API를 이용하여 대기열 정보를 편하게 카톡으로 받아보면 어떨까 하는 생각이 들게 되었다. 게임플레이와 개발을 동시에 할 수 있는 찬스였다. loaq.kr의 대기열 데이터의 원천을 알고싶었지만 결국 알아내지 못하였다. 로스트아크 측에서 별도의 API는 제공해주지 않는 것 같았다.그리하여 개발 프로세스는 다음과 같이 구상하였다. loaq.kr의 데이터를 크롤링한다. 크롤링한 데이터를 가공하여 json형태로 제공한다. json형태로 제공받은 데이터를 kakao 플러스친구 api를 통해 서비스 한다. 1. loaq.kr의 데이터를 크롤링한다.크롤러의 경우 selenium를 자주 써봤어서 고려해봤지만 브라우저를 사용하는 selenium 특성상 request당 매번 빠르게 크롤링 해야하는 이번 서비스에는 어울리지 않겠다는 생각이 들었다.그래서 대중적으로 많이 사랑받는 BeautifulSoup를 사용하였다. 우선 loaq.kr의 구조를 파악했다. 123456789101112131415161718192021&lt;div class=\"server-list\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"cell col-center\"&gt; 루페온 &lt;/div&gt; &lt;div class=\"cell col-center\"&gt; &lt;div&gt; &lt;span class=\"red\"&gt;2348&lt;/span&gt; &amp;nbsp; &lt;/div&gt; &lt;div&gt; &lt;span class=\"small-text bottom-text blue\"&gt; &amp;nbsp;(▼1183) &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"cell col-center\"&gt; &lt;a href=\"/server/1\"&gt;상세보기&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;... 서버 한개의 row구조는 저렇게 이루어져 있었고 서버명과 대기자 데이터를 끌어오려면 적합한 selector가 div.server-list라고 생각되어서 그렇게 정했다. 공백, (▼1183)와 같은 등락데이터, 상세보기, 테이블의 헤더 등등 불필요한 정보를 정리했다. 123456789for tag in soup.select('div.server-list'): server_name += tag.textserver_name = server_name.replace(' ', '').split(\"\\n\")server_name = [x for x in server_name if \"(\" not in x and \"상세\" not in x and \"서버\" not in x and \"대기열\" not in x and \"\\xa0\" not in x and \"\" != x] 2. 크롤링한 데이터를 가공하여 json형태로 제공한다.정제된 데이터가 준비 되었으니 이제 json으로 제공할 준비를 한다.123456789&#123; \"server_time\": \"2018-11-18 15:49:49\", \"items\": [ &#123; \"server\": \"루페온\", \"wait\": \"13744\" &#125; ]&#125; json의 형태를 위와 같이 준비해보았다.처음으로 만들어보는 api여서 그런지 형태가 아직 성에 차진않는다.그래도 이정도 모양새면 어느정도 적절히 필요한 데이터들을 담고 제공할 수 있는 형태가 되었다고 생각된다. 123456789servers = &#123;&#125;servers['server_time'] = soup.select('div.time')[0].text.replace(\" \",\"\").replace('\\n', '')for i, item in enumerate(server_name): if i % 2 == 0: items.append(&#123;\"server\": item, \"wait\": server_name[i + 1]&#125;)servers[\"items\"] = items 3. json형태로 제공받은 데이터를 kakao 플러스친구 api를 통해 서비스 한다.처음엔 node.js를 이용해서 비동기 서비스를 제공해볼 생각이었지만 크롤러와 같은 언어를 사용하는 것이 정신건강에 좋을것 같다는 생각이 주마등처럼 스쳐 지나갔다.그래서 python의 web framework중 하나인 flask를 사용해보았다.django는 몇 번 사용해봤지만 flask는 이런 작은 서비스에 어울린다고 생각이 되어서 채택하게 되었다. flask에 대한 자세한 내용은 이 글의 주제에서 벗어나기 때문에 다음에 더욱 다뤄보도록 하겠다. 플러스친구 계정을 만든 후 스마트채팅-API가 사진과 같이 설정 되어있어야한다. 대화방에 첫 진입시 보여줄 keyboard를 정의하는 코드이다.1234567@app.route('/keyboard')def Keyboard(): dataSend = &#123; \"type\": \"buttons\", \"buttons\": [\"대기열\", \"명령어\"] &#125; return jsonify(dataSend) 다음은 각 상황(메뉴)별 시나리오를 구현한 message이다.현재 우리의 서비스는 매우 단순하기 때문에 간단하게 구성되어있다.keyboard의 대기열 버튼이 클릭되면 데이터를 보여주는 형태이다. 크롤러에서 받아온 json 데이터를 이용해 실제로 보여줄 message를 구성한다.마지막에 dataSend[&quot;keyboard&quot;] = {&quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [&quot;대기열&quot;, &quot;명령어&quot;]} 를 추가하여 모든 화면에서 keyboard가 동작하게 만들어준다. 123456789101112131415161718192021222324252627282930313233@app.route('/message', methods=['POST'])def Message(): dataReceive = request.get_json() content = dataReceive['content'] if content == u\"대기열\": cr = Crawler() json_file = cr.start() text = f\"서버시간 - &#123;json_file['server_time']&#125;\\n\\n\" for item in json_file['items']: text += f\"&#123;item['server']&#125; - &#123;item['wait']&#125;\\n\" dataSend = &#123; \"message\": &#123; \"text\": text &#125; &#125; elif content == u\"명령어\": dataSend = &#123; \"message\": &#123; \"text\": \"1. 대기열\\n2. 명령어\" &#125; &#125; else: dataSend = &#123; \"message\": &#123; \"text\": \"명령어를 다시 입력해주세요. 1. 대기열, 2.명령어\" &#125; &#125; dataSend[\"keyboard\"] = &#123;\"type\": \"buttons\", \"buttons\": [\"대기열\", \"명령어\"]&#125; return jsonify(dataSend) 하루만에 급조한 프로그램이라 완성도가 많이 떨어지지만 현재도 많은 사람들이 이용해주셔서 감사할 따름이다 😊 http://www.inven.co.kr/board/lostark/4821/5381로스트아크 인벤에서도 많은 분들이 이용해주시고 계신다. https://pf.kakao.com/_dcPGj 현재 기준으로 3000명을 돌파했다! ❤️❤️❤️이번 서비스 개발은 귀찮음을 벗어나려고 시작한 몸부림에 비해 꽤나 보람찬 개발이었다는 생각이 든다. 앞으로도 이런 아이디어가 떠오르면 편리함을 위해 편리함을 개발하는 개발자가 될 것이다. 🛴","categories":[{"name":"Web","slug":"Web","permalink":"http://suitee.me/categories/Web/"},{"name":"API","slug":"Web/API","permalink":"http://suitee.me/categories/Web/API/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"http://suitee.me/tags/Crawler/"},{"name":"API","slug":"API","permalink":"http://suitee.me/tags/API/"},{"name":"json","slug":"json","permalink":"http://suitee.me/tags/json/"},{"name":"Kakao plus friend","slug":"Kakao-plus-friend","permalink":"http://suitee.me/tags/Kakao-plus-friend/"}]},{"title":"탑코더 알고리즘 정복 - 4. 재미있는 수학","slug":"ps-interesting-digits","date":"2018-11-06T04:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/11/06/ps-interesting-digits/","link":"","permalink":"http://suitee.me/2018/11/06/ps-interesting-digits/","excerpt":"","text":"문제숫자 3과 9는 재미있는 성질이 있습니다. 3의 배수의 각 자릿수의 합은 다른 3의 배수가 됩니다.예를 들어 $118x3=358$이고 $3+5+4=12$는 3의 배수입니다. 마찬가지로 9의 배수의 각 자릿수의 합은다른 9의 배수가 됩니다. 예를 들어 $75x9=675$이고 $6+7+5=18$은 9의 배수입니다.base 진법이 주어졌을 때 이러한 성질을 가진 수를 오름차순으로 모두 리턴하세요(0과 1은 제외)어떤 수가 이러한 성질을 가지는지 알고자 모든 숫자의 곱을 고려할 필요는 없습니다.만약 4자리 미만의 곱으로 성립되면 더 큰 자리에서도 성립된다 할 수 있습니다. 예를 들어 10진수 에서는999보다 큰 숫자를 고려하지 않아도 됩니다. 정의12class InterestingDigits: def digits(self, base): 입력base : 3~30의 정수 출력정수를 담고있는 배열 IO Example12345678910111213141516171819# Case# 0base = 10returns = [3, 9]# Case# 1base = 3returns = [2]# Case# 2base = 9returns = [2, 4, 8]# Case# 3base = 26returns = [5, 25]# Case# 4base = 30returns = [29] 구현1차 코드12345678910111213141516171819202122class InterestingDigits: def digits(self, base): ans = [] for n in range(2, base): ok = True for k1 in range(base): for k2 in range(base): for k3 in range(base): if (k1 + k2 * base + k3 * base * base) % n == 0 and (k1 + k2 + k3) % n != 0: # n의 배수 숫자로 각 숫자의 합이 n의 배수가 아니면 # n을 제외합니다. ok = False break if not ok: break if not ok: break if ok: ans.append(n) return ans 2차 코드수학적인 방법으로 풀면이번 문제가 요구하는 답은 (n-1)과 그 약수이다. 그러므로 그 답만 구하면 된다.123456789class InterestingDigits: def digits(self, base): ans = [] for i in range(2, base): if ((base - 1) % i) == 0: ans.append(i) return ans 마무리 단순한 전체 탐색모든 경우를 샅샅이 뒤지는 탐색을 하는 것은 사실 간단하지 않고 이 문제가 전체 탐색으로 풀 수 있는 문제인지눈치채기 쉽지 않다.그러므로 관련된 문제를 많이 접해보면서 익숙해지는 것이 좋다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"},{"name":"Top Coder","slug":"Algorithm/Top-Coder","permalink":"http://suitee.me/categories/Algorithm/Top-Coder/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/tags/Algorithm/"},{"name":"전체 탐색","slug":"전체-탐색","permalink":"http://suitee.me/tags/전체-탐색/"}]},{"title":"탑코더 알고리즘 정복 - 3. 암호","slug":"ps-cryptography","date":"2018-11-05T04:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/11/05/ps-cryptography/","link":"","permalink":"http://suitee.me/2018/11/05/ps-cryptography/","excerpt":"","text":"문제TopCoder Security Agency(TSA, 오늘 설립되었어요!)는 새로운 암호화 시스템을 개발했습니다.이 시스템은 암호화하려고 숫자 리스트를 입력받습니다. 여러분은 TSA의 비밀 정보 수사원입니다. 암호화 과정에서 중요한 부분을 구현하는 것이 여러분의 일입니다.여러분은 입력 리스트에서 1개의 값을 선택하고 값을 1 증가시킵니다. 이때 리스트 내부의 모든 숫자 곱이가장 커져야 합니다. int[] numbers 형태로 숫자 배열이 주어질 때 곱의 최댓값을 리턴하세요. 리턴값이 $2^62$를 넘는 문제는 나오지 않을 것을 보장합니다. 정의12class Cryptography: def encrypt(self, numbers): 입력numbers : 2~50개의 요소가 있는 배열이며 각 요소의 값은 1~1000입니다. 출력정수를 담고있는 변수 IO Example123456789101112131415# Case# 0numbers=[1, 2, 3]returns=12# Case# 1numbers=[1, 3, 2, 1, 1, 3]returns=36# Case# 2numbers=[1000, 999, 998, 997, 996, 995]returns=986074810223904000# Case# 3numbers=[1, 1, 1, 1]returns=2 구현1차 코드 +1 하는 숫자를 정한다. 그리고 모든 곱을 계산하고 최댓값을 선택한다. 1234567891011121314class Cryptography: def encrypt(self, numbers): ans = 0 for i in range(len(numbers)): temp = 1 for j in range(len(numbers)): if i == j: temp *= numbers[i] + 1 else: temp *= numbers[j] ans = max(ans, temp) return ans 2차 코드 +1 하는 숫자는 최소값. 그리고 모든 곱을 계산한다.1234567891011class Cryptography: def encrypt(self, numbers): ans = 1 numbers = sorted(numbers) numbers[0] += 1 for number in numbers: ans *= number return ans 마무리 수학적 지식이 있으면 좋다수학적 지식이 있다면 2차 코드처럼 간결하게 바로 풀었겠지만 그렇지 않더라도 전체 탐색으로 해결할 수 있었다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"},{"name":"Top Coder","slug":"Algorithm/Top-Coder","permalink":"http://suitee.me/categories/Algorithm/Top-Coder/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/tags/Algorithm/"},{"name":"전체 탐색","slug":"전체-탐색","permalink":"http://suitee.me/tags/전체-탐색/"}]},{"title":"탑코더 알고리즘 정복 - 2. 즐거운 파티","slug":"ps-interesting-party","date":"2018-11-04T16:21:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/11/04/ps-interesting-party/","link":"","permalink":"http://suitee.me/2018/11/04/ps-interesting-party/","excerpt":"","text":"문제화이트씨는 다재다능한 사람입니다.(모든 것이 그의 관심 대상입니다). 그래서 그에게는 친구가 많습니다.하지만 불행하게도 그의 친구들은 다재다능하지 않습니다. 각각의 친구는 2가지 주제에만 관심이 있고다른 주제로 이야기 하는 것을 싫어합니다. 그래서 파티를 개최할 때마다 모두가 즐겁게 파티를 보내려면어떤 친구를 초대할지가 큰 문제입니다. 화이트씨는 그동안의 경험으로 초대된 친구 모두가 공통의 흥미 있는화제가 있을 때 파티를 즐긴다는 것을 알았습니다. 문자열 배열 first, second가 주어집니다. 화이트씨의 i번째 친구가 흥미있는 화제는 first[i]와second[i]입니다. 즐거운 파티가 되려면 화이트씨가 초대할 수 있는 친구는 최대 몇 명 인지 리턴하세요. 정의12class InterestingParty: def best_invitaion(self, first, second): 입력first : 1~50개의 요소가 있는 배열.second : 1~50개의 요소가 있는 배열.first, second 공통 : 각 요소는 1~15개 문자이며, 각 문자는 영어 소문자입니다.i번째 요소 first[i]와 second[i]의 내용은 다릅니다. 출력정수를 담고있는 변수 IO Example123456789101112131415161718192021# Case# 0first = ['fishing', 'gradening', 'swimming', 'fishing']second = ['hunting', 'fishing', 'fishing', 'biting']result = 4# Case# 1first = ['Variety', 'diversity', 'loquacity', 'courtesy']second = ['talking', 'speaking', 'discussion', 'meeting']result = 1# Case# 2first = ['snakes', 'programming', 'cobra', 'monty']second = ['python', 'python', 'anaconda', 'python']result = 3# Case# 3first = ['t', 'o', 'p', 'c', 'o', 'd', 'e', 'r', 's', 'i', 'n', 'g', 'l', 'e', 'r', 'o', 'u', 'n', 'd', 'm', 'a', 't', 'c', 'h', 'f', 'o', 'u', 'r', 'n', 'i']second = ['n', 'e', 'f', 'o', 'u', 'r', 'j', 'a', 'n', 'u', 'a', 'r', 'y', 't', 'w', 'e', 'n', 't', 'y', 't', 'w', 'o', 's', 'a', 't', 'u', 'r', 'd', 'a', 'y']result = 6 구현1차 코드이중 반복문을 이용하여 모든 요소에 대해 중복되는 항목들의 갯수를 구한 뒤 ans와 비교하여 더 큰 값을담도록 한다. 12345678910111213141516171819202122class InterestingParty: def best_invitation(self, first, second): ans = 0 for i in range(len(first)): f = 0 s = 0 for j in range(len(first)): if first[i] == first[j]: f += 1 if first[i] == second[j]: f += 1 if second[i] == first[j]: s += 1 if second[i] == second[j]: s += 1 ans = max(f, ans) ans = max(s, ans) return ans 2차 코드가독성이 좋지 않은 이중 반복문을 대체하여 dictionary를 사용해서 구현하였다.dic에 모든 단어들을 등록한 후 배열들을 검사하여 중복되는 항목의 값을 1 증가시킨다.그 후 가장 값이 큰 항목을 리턴한다. 1234567891011121314151617class InterestingParty: def best_invitation(self, first, second): dic = &#123;&#125; for i in range(len(first)): dic[first[i]] = 0 dic[second[i]] = 0 for i in range(len(first)): dic[first[i]] += 1 dic[second[i]] += 1 ans = 0 for key in dic: ans = max(ans, dic[key]) return ans 마무리 문제를 이해하고 전체탐색 떠올리기 즐거운 파티가 되려면 화이트씨가 초대할 수 있는 친구는 최대 몇 명 인지 리턴하세요. 가장 많은 것을 답하라는 문제는 전체 탐색 을 머리속에 떠올려야 한다. 모든 문제가 수학적 지식이 필요한 것은 아니다.아무리 수학이 나오는 문제라도 전체 탐색을 이용하면 간단하게 해결할 수도 있다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"},{"name":"Top Coder","slug":"Algorithm/Top-Coder","permalink":"http://suitee.me/categories/Algorithm/Top-Coder/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/tags/Algorithm/"},{"name":"전체 탐색","slug":"전체-탐색","permalink":"http://suitee.me/tags/전체-탐색/"}]},{"title":"마크다운(Markdown)문법 대-백과","slug":"markdown-dictionary","date":"2018-10-31T07:21:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/10/31/markdown-dictionary/","link":"","permalink":"http://suitee.me/2018/10/31/markdown-dictionary/","excerpt":"","text":"오늘은 사용할 때마다 가물가물한 마크다운 문법에 대해 정리를 해두려고한다. 제목 Headers#와 숫자를 사용하여 제목을 작성할 수 있다. 마크다운 실행결과 # H1## H2### H3#### H4##### H5###### H6 H1 H2 H3 H4 H5 H6 또는 -, =을 이용하여 H1, H2를 쓸 수 있다. 마크다운 실행결과 h1===h2—- h1 h2 인용 Blockquotes&gt;을 사용하여 인용 문구를 작성할 수 있다. 마크다운 실행결과 &gt; 인용문 인용문 &gt;&gt; 인용문안의 인용문 인용문 인용문 &lt;/blockquote&gt; 코드 블럭 Code Blocks``` 혹은 ~~~ 코드 첫 줄과 마지막 줄에 Back quote ( ` ) 또는 물결( ~ ) 3개 삽입 마크다운 실행결과 ```이것은코드 블럭입니다```~~~ 이것은 코드 블럭입니다~~~ 123이것은코드 블럭입니다123이것은코드 블럭입니다 ```cvoid f() printf(%s,“이것은 c 코드 입니다”);}``` 123void f()&#123; printf(%s,\"이것은 c 코드 입니다\");&#125; 인라인 코드 Inline Code Blocks`(Back quote)로 감싸진 텍스트 마크다운 실행결과 `인라인 코드 블럭` 인라인 코드 블럭 강조 Emphasis기울여 쓰기(italic) : * 또는 _로 감싼 텍스트굴게쓰기(bold) : ** 또는 __로 감싼 텍스트 마크다운 실행결과 *기울여쓰기(italic)*_기울여쓰기(italic)_**굵게쓰기(bold)**__굵게쓰기(bold)__ 기울여쓰기(italic)기울여쓰기(italic)굵게쓰기(bold)굵게쓰기(bold) 수평선 Horizontal Rules- 또는 * 또는 _ 을 3개 이상 작성(단, -을 사용할 경우 header로 인식할 수 있으니 이 전 라인은 비워두어야한다.) 마크다운 실행결과 --- *** ___ 링크 Links외부 링크 External Links[링크](http://example.com &quot;링크 제목&quot;) 인라인 링크[링크1][1] [1]: http://example1.com/ &quot;링크제목1&quot; 참조 링크&lt;example.com/&gt; &lt;example@example.com&gt; url 링크 마크다운 실행결과 인라인 링크 \\[Google\\](http://www.google.co.kr \"구글\") Google 참조 링크 [Google][1][Naver][2][1]: http://google.com/ “구글”[2]: http://naver.com/ “네이버” GoogleNaver URl 링크&#60;http://google.com/&#62;&#60;example@gmail.com/&#62; http://google.com&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109; 내부 링크 Internal (Anchored) Links[링크](#id) 내부 링크 마크다운 실행결과 [목차](#index) 목차 리스트 Lists순서 있는 리스트 Ordered ListsNo. 숫자 다음 .을 찍는다. (적힌 숫자랑 상관없이 순서대로 번호가 매겨진다.) 마크다운 실행결과 1. list item 11. list item 22. list item 30. list item 43. list item 5 list item 1list item 2list item 3list item 4list item 5 순서 없는 리스트 Unordered Lists*, +, - 으로 시작 마크다운 실행결과 * list item 1 \\* list item 1-1 \\* list item 1-2 list item 1list item 1-1list item 1-2&lt;/ul&gt; + list item 1 \\+ list item 1-1 \\+ list item 1-2 list item 1list item 1-1list item 1-2&lt;/ul&gt; - list item 1 \\- list item 1-1 \\- list item 1-2 list item 1list item 1-1list item 1-2&lt;/ul&gt; 테이블 Tables 마크다운 실행결과 테이블 생성Header 1 &#124; Header 2&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &#124; &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;Content 1 &#124; Content 3Content 2 &#124; Content 4 Header 1Header 2Content 1Content 3Content 2Content 4 테이블 정렬&#124; Header 1 &#124; Header 2 &#124; Header 3 &#124;&#124; :&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &#124; :&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;: &#124; &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;: &#124;&#124; Left &#124; Center &#124; Right &#124; Header 1Header 2Header 3LeftCenterRight 이미지 Adding Images 마크다운 실행결과 인라인 이미지!&#91;alt text&#93;&#40;/test.png &#41; 링크 이미지!&#91;alt text&#93;&#40;image_URL&#41; 참조 이미지!&#91;alt text&#93;&#91;1&#93;&#91;1&#93;: B9653641350_l.jpg","categories":[{"name":"Blog","slug":"Blog","permalink":"http://suitee.me/categories/Blog/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://suitee.me/tags/Markdown/"},{"name":"Post","slug":"Post","permalink":"http://suitee.me/tags/Post/"}]},{"title":"탑코더 알고리즘 정복 - 1. 키위 주스","slug":"ps-kiwi-juice-easy","date":"2018-10-29T16:21:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/10/29/ps-kiwi-juice-easy/","link":"","permalink":"http://suitee.me/2018/10/29/ps-kiwi-juice-easy/","excerpt":"","text":"문제타로는 맛있는 키위 주스를 준비했습니다.타로는 0부터 N-1이라 이름을 붙인 N개의 병에 키위 주스를 넣었습니다.이때 i번째의 병의 용량은 capacities[i] 리터이며 타로가 i번째 병에 넣은 키위 주스의 양을 bottles[i] 리터라고 합니다. 타로는 병에 키위 주스를 재분배하려고 하며, 0부터 M-1까지 M회 조작합니다.i번쨰의 조작은 타로가 병 fromId[i]부터 병 toId[i]에 키위 주스를 넣는 것을 의미합니다.병 fromId[i]가 비어 있거나 병 toId[i]가 꽉 차 있는 순간, 타로는 더 이상 키위 주스를 넣지 않습니다. N개의 요소를 가진 정수 배열 int[]를 리턴해주세요.배열의 i번째 요소는 모든 주스를 쏟는 작업이 완료되고 i번째 병에 남아 있는 키위 주스의 양입니다. 정의12class KiwiJuiceEasy: def thePouring(self, capacities, bottles, fromId, told): 입력capacities : 2~50개의 요소가 있는 배열, 각 요소는 1 &lt;= N &lt;= 1000000 사이의 값을 갖는다.bottles : capacities와 같은 수의 요소가 있는 배열. bottles[i]는 capacities[i]에 들어있는 주스의 양을 의미fromId : 1~50개의 요소가 있는 배열toId : fromId와 같은 수의 요소가 있는 배열 출력병들에 남아있는 주스의 양을 담고 있는 배열 IO Example123456789101112131415161718192021222324252627282930313233343536373839# Case# 0capacities = [20, 20]bottles = [5, 8]from_id = [0]to_id = [1]result : [0, 13]# Case# 1capacities = [10, 10]bottles = [5, 8]from_id = [0]to_id = [1]result : [3, 10]# Case# 2capacities = [30, 20, 10]bottles = [10, 5, 5]from_id = [0, 1, 2]to_id = [1, 2, 0]result : [10, 10, 0]# Case# 3capacities = [14, 35, 86, 58, 25, 62]bottles = [6, 34, 27, 38, 9, 60]from_id = [1, 2, 4, 5, 3, 3, 1, 0]to_id = [0, 1, 2, 4, 2, 5, 3, 1]result : [0, 14, 65, 35, 25, 35]# Case# 4capacities = [700000, 800000, 900000, 1000000]bottles = [478478, 478478, 478478, 478478]from_id = [2, 3, 2, 0, 1]to_id = [0, 1, 1, 3, 2]result : [0, 156956, 900000, 856956] 구현1차 코드1차로 작성한 코드는 모든 경우의 수를 나열하려고 노력했었던 것 같다.모든 5개의 테스트케이스는 통과했지만,조건문을 4개나 사용하고 작업 후에 ret배열에 새로 담는 불필요한 행동까지 하면서 메모리와 소스코드의 난독화를 유발한 것 같다. 12345678910111213141516171819202122232425262728293031323334class KiwiJuiceEasy: def the_pouring(self, capacities, bottles, from_id, to_id): ret = [] for i in range(len(from_id)): from_i = from_id[i] to_i = to_id[i] # 옮길 병이 비어있으면 pass if bottles[from_i] == 0: continue # 담길 병이 꽉차있으면 pass if bottles[to_i] == capacities[to_i]: continue # 옮길 병의 용량보다 from + to의 내용물이 적거나 같으면 # bottles[to_i]에 주스를 옮김. if bottles[from_i] + bottles[to_i] &lt;= capacities[to_i]: bottles[to_i] += bottles[from_i] bottles[from_i] = 0 # 옮길 병의 용량보다 from + to의 내용물이 많으면 # bottles[to_i]에 주스를 옮기고 나머지를 from에 남김. elif bottles[from_i] + bottles[to_i] &gt; capacities[to_i]: tmp = bottles[to_i] + bottles[from_i] - capacities[to_i] bottles[to_i] = capacities[to_i] bottles[from_i] = tmp # 모든 bottles를 ret에 담음 for bottle in bottles: ret.append(bottle) return ret 2차 코드2차로 작성한 코드는 조건문이 필요이상으로 많으면 코드 양이 늘어나고 버그를 찾기 힘들게 된다.이 문제의 경우 if문을 min함수로 대체할 수 있었다.옮길 주스의 양과 기존 주스 병의 남은 용량을 비교하여 작은 것이 이동량이 되기 때문이다.min함수로 대체하면서 조건문이 꽤나 사라져서 코드의 가독성이 훨씬 좋아졌다.그리고 ret 배열을 제거하여 바로 bottles 배열을 return하게끔 하였다. 12345678910111213141516class KiwiJuiceEasy: def the_pouring(self, capacities, bottles, from_id, to_id): for i in range(len(from_id)): f = from_id[i] t = to_id[i] # 옮길 주스의 양과 기존 주스 병의 남은 용량을 비교해 # 작은 것이 이동량이 된다. vol = min(bottles[f], capacities[t] - bottles[t]) # 옮길 주스 병에 이동량을 뺀다. bottles[f] -= vol # 기존 주스 병의 남은 용량에 이동량을 더한다. bottles[t] += vol return bottles 3차 코드3차로 작성한 코드는 반복문 내부의 로직이 무려 3줄이다!!시작부에 f와 t의 변수 선언을 제거함으로써 숏코딩이 되었지만 가독성면에선 조금 불편해졌다고 느껴진다.하지만 프로세스는 꽤나 심플하다.이동량을 무시하고 옮길 주스와 기존 주스 양의 총합이 일정하고,옮길 주스는 주스 총량과 기존 주스 병의 용량 중에 작은 값이 된다는 것을 이용하기로 했다. 기존 주스(bottles[to_id[i]]) : min(옮길 주스 + 기존 주스, 기존 주스 병의 용량) 옮길 주스(bottles[from_id[i]]) : (옮길 주스 + 기존 주스) - 기존 주스 12345678class KiwiJuiceEasy: def the_pouring(self, capacities, bottles, from_id, to_id): for i in range(len(from_id)): sum = bottles[from_id[i]] + bottles[to_id[i]] bottles[to_id[i]] = min(sum, capacities[to_id[i]]) bottles[from_id[i]] = sum - bottles[to_id[i]] return bottles 마무리 문제를 이해했다면 손으로 계산해보기.머리로만 문제를 해결하려고 하면 표면적인 부분까지 밖에 생각하지 못함.여러가지 경우의 수를 생각하며 문제를 이해해보기.어떻게 코드를 작성해야겠다 생각이 들어도 누락된 부분이 없는지 확인하기. 코딩이 오래 걸린다면 다시 한 번 손으로 생각해보기.많은 것을 생각하고 코드를 작성해도 예상하지 못한 곳에서 문제가 발생 할 수 있음.이럴땐 코드 작성을 중단하고 문제를 다시 생각해보기. 조건문을 되도록 조금 사용하기.모든 문제가 Example에서 모든 Testcase를 주는 것은 아니기 때문에 가능한 조건문을 적게 사용해 버그를 줄여야 한다.","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"},{"name":"Top Coder","slug":"Algorithm/Top-Coder","permalink":"http://suitee.me/categories/Algorithm/Top-Coder/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/tags/Algorithm/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"http://suitee.me/tags/시뮬레이션/"}]},{"title":"탑코더 알고리즘 정복 시-리즈","slug":"ps-top-coder-intro","date":"2018-10-29T08:22:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/10/29/ps-top-coder-intro/","link":"","permalink":"http://suitee.me/2018/10/29/ps-top-coder-intro/","excerpt":"","text":"여러가지 문제를 풀어봤지만 알고리즘에 대해 따로 시간을 내어 공부하거나 문제해결 방법론에 대해 깊게 생각해본 적이 없는 것같다.물론 알고리즘 문제 해결에 대해서는 소소한 취미로 생각할 정도로 즐거워 하지만 전문적이진 않았던 것이다. 평소와 다르게 콘크리트마냥 굳어버린 내 두뇌와개발 직종 입사전형의 필수코스, 고오급 코스요리 식당의 메인요리를 먹기 전 전채같은 코딩 테스트를 위해 알고리즘을 집중적으로 고시생처럼 공부할 때가 온 것이다. 그리하여 많은 개발자들의 입에 오르내린 책을 한 권 주문하게 되었다.빨간책이라고 불리며 종만북과 함께 인기가 엄청난 책이다. 종만북이 난이도가 꽤나 있다고 해서 빨간책을 먼저 택하게 되었다. 여지껏 블로그 포스팅에 게을렀지만, 이번엔 이 빨간책의 문제와 해결방법을 비정기적이지만 매일 한 문제 이상 포스팅할 예정이다.작심삼일이 아니길..","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"},{"name":"Top Coder","slug":"Algorithm/Top-Coder","permalink":"http://suitee.me/categories/Algorithm/Top-Coder/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/tags/Algorithm/"}]},{"title":"머신러닝의 네가지 분류","slug":"classification-ml","date":"2018-10-20T16:21:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2018/10/20/classification-ml/","link":"","permalink":"http://suitee.me/2018/10/20/classification-ml/","excerpt":"","text":"지도 학습(supervised learning)샘플 데이터가 주어지면 알고 있는 타겟(annotation)에 입력 데이터를 매핑하는 방법을 학습 OCR 음성인식 Image Classification 언어번역 등등 거의 모든 애플리케이션이 이 범주에 속함 대부분 분류와 회귀로 구성되지만 다음과 같은 특이한 변종도 많다. 시퀀스 생성(squence generation) : 사진이 주어지면 이를 설명하는 캡션을 생성. 시퀀스 생성은 일련의 분류 문제로 재구성할 수 있음. 구문 트리(syntax tree) 예측 : 문장이 주어지면 분해된 구문 트리를 예측. 물체 감지(object detection) : 사진이 주어지면 사진 안의 특정 물체 주위에 경계 상자(bounding box)를 그림.상자의 내용을 분류하는 문제로 표현되거나, 경계 상자의 좌표를 벡터 회귀로 예측하는 회귀와 분류가 결합된 문제로 표현할 수 있음. 이미지 분할(image segmentation) : 사진이 주어졌을 때 픽셀 단위로 특정 물체에 마스킹(masking)을 함. 비지도 학습(unsupervised learning)어떤 타겟도 사용하지 않고 입력 데이터에 대한 흥미로운 변환을 찾는다.데이터 시각화, 데이터 압축, 데이터의 노이즈 제거, 데이터에 있는 상관관계를 더 잘 이해하기위해 사용.데이터 분석에서 주로 사용하며 지도 학습 문제를 풀기 전에 필수적으로 거치는 단계.차원 축소(dimensionality reduction)와 군집(clustering)이 비지도 학습에서 잘 알려진 범주 자기 지도 학습(self-supervised learning)지도 학습의 특별한 경우이지만 별도의 범주로 할 만큼 충분히 다름.지도 학습이지만 사람이 만든 레이블을 사용하지 않음.즉 학습 과정에 사람이 개입하지 않는 지도 학습이라고 생각할 수 있음.레이블은 필요하지만 보통 경험적인 알고리즘(heuristic algorithm)을 사용해서 입력 데이터로부터 생성 오토인코더(autoencoder) 지난 프레임이 주어졌을 때 비디오의 다음 프레임을 예측 이전 단어가 주어졌을 때 다음 단어를 예측하는 것 강화 학습(reinforcement learning)강화 학습에서 에이전트(agent)는 환경에 대한 정보를 받아 보상을 최대화하는 행동을 선택하도록 학습된다. 아타리 알파고 자율 주행 자동차 자원 관리 교육 분류와 회귀에서 사용하는 용어 샘플 또는 입력 : 모델에 주입될 하나의 데이터 포인트. 예측 또는 출력 : 모델로부터 나오는 값. 타깃 : 정답, 외부 데이터 소스에 근거하여 모델이 완벽하게 예측해야하는 값. 예측 오차 또는 손실 값 : 모델의 예측과 타겟 사이의 거리를 측정한 값. 클래스 : 분류 문제에서 선택할 수 있는 가능한 레이블의 집합.예를 들어 고양이와 강아지 사진을 분류할 때 클래스는 ‘고양이’, ‘강아지’ 2개이다. 레이블 : 분류 문제에서 클래스 할당의 구체적인 사례.예를 들어 사진1에 ‘강아지’클래스가 들어 있다고 표시한다면 ‘강아지’는 사진1의 레이블이 된다. 참 값(ground-truth) 또는 꼬리표(annotation) : 데이터 셋에 대한 모든 타겟, 일반적으로 사람에 의해 수집. 이진 분류 : 각 입력 샘플이 2개의 배타적인 범주로 구분되는 분류 작업. 다중 분류 : 각 입력 샘플이 2개 이상의 범주로 구분되는 분류 작업.예를 들어 손글씨 숫자 분류를 말한다. 다중 레이블 분류 : 각 입력 샘플이 여러 개의 레이블에 할당될 수 있는 분류 작업.예를 들어 하나의 이미지에 고양이와 강아지가 모두 들어 있을 때는 ‘고양이’ 레이블과 ‘강아지’ 레이블을 모두 할당해야 함. 스칼라 회귀 : 타겟이 연속적인 스칼라 값인 작업. 주택 가격 예측이 좋은 예이다. 벡터 회귀 : 타겟이 연속적인 값의 집합인 작업. 예를 들어 연속적인 값으로 이루어진 벡터(이미지에 있는 경계 상자의 좌표 등)여러 개의 값에 대한 회귀를 한다면 벡터 회귀이다. 미니 배치 또는 배치 : 모델에 의해 동시에 처리되는 소량의 샘플 묶음(일반적으로 8개에서 128개 사이).샘플 개수는 GPU의 메모리 할당이 용이하도록 2의 거듭제곱으로 하는 경우가 많다.훈련할 때 미니 배치마다 한 번씩 모델의 가중치에 적용할 경사 하강법 업데이트 값을 계산한다.","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"Basic","slug":"Deep-Learning/Basic","permalink":"http://suitee.me/categories/Deep-Learning/Basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"}]},{"title":"선택정렬 알고리즘(selection sort) 구현하기 with Python","slug":"selection-sort-with-python","date":"2018-08-27T06:06:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/08/27/selection-sort-with-python/","link":"","permalink":"http://suitee.me/2018/08/27/selection-sort-with-python/","excerpt":"","text":"선택 정렬(Selection sort)학생때 알고리즘 시간에 공부했던 내용이지만,최근에 정보처리기사 공부, 알고리즘 공부를 하면서 겸사 겸사 되짚어 보았다. 이론주어진 배열을 순회하면서 선택된 항목과 그 다음 항목들 중에 최소 값을 찾아서 서로 교환해준다.아래의 그림을 보면서 이해하면 느낌이 올 것이다.노란색은 선택된 항목, 주황색은 최소 값이다. 소스코드역시 개발자는 소스코드로 확인하는 편이 이해가 빠르다. 한 라인에 배열을 “3 5 1 2 4” 형식으로 공백구분으로 받은 후배열을 순회하면서 최소 값의 index를 구하고 선택된 항목과 교환하는 내용이다. 1234567891011arr = list(map(int, input().split()))for i in range(len(arr)): min_idx = i for j in range(i + 1, len(arr)): if arr[min_idx] &gt; arr[j]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i]print(' '.join(map(str,arr)))","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"}]},{"title":"문장의 유사도 분석하기(레벤슈타인 거리, N-gram)","slug":"n-gram","date":"2018-07-29T21:35:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/07/29/n-gram/","link":"","permalink":"http://suitee.me/2018/07/29/n-gram/","excerpt":"","text":"문장의 유사도 분석단어 또는 문장의 유사도를 분석하는 방법 중에는 레벤슈타인 거리, N-gram 등이 있다.오늘은 이 방법들에 대해서 알아볼 것이다. 레벤슈타인 거리(Lvenshtein distance)레벤슈타인 거리는 두 단어 또는 문장의 차이를 통해 거리를 수치로 나타내는 것이다.철자 오류 수정, 비슷한 어구 검색 등에 사용되고, 의학 분야에서는 DNA 배열의 유사성을 판단할 때도 사용하고 있다. 예를 들어‘가나다라’를 ‘가마바라’로 수정할 때 몇 번의 수정이 필요한 지를 거리로 나타낼 수 있다. 0 가나다라1 가’마’다라2 가마’바’라 ‘가나다라’-&gt; ‘가마바라’는 거리가 2임을 알 수 있다. 코드로 알아보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def calc_distance(a, b): if a == b: return 0 a_len = len(a) b_len = len(b) if a == \"\": return b_len if b == \"\": return a_len # 2차원 표 (a_len+1, b_len+2) 준비하기 matrix = [[] for i in range(a_len+1)] for i in range(a_len+1): matrix[i] = [0 for j in range(b_len+1)] # 0일 때 초기값을 설정 for i in range(a_len+1): matrix[i][0] = i for j in range(b_len+1): matrix[0][j] = j # 표 채우기 for i in range(1, a_len+1): ac = a[i-1] for j in range(1, b_len+1): bc = b[j-1] cost = 0 if (ac == bc) else 1 matrix[i][j] = min([ matrix[i-1][j] + 1, # 문자 삽입 matrix[i][j-1] + 1, # 문자 제거 matrix[i-1][j-1] + cost # 문자 변경 ]) return matrix[a_len][b_len]print(calc_distance('가나다라', '가마바라'))# result : 2samples = ['신촌역', '신쵼', '신천군', '신천역', '신발', '마곡역']base = samples[0]r = sorted(samples, key = lambda n: calc_distance(base, n))for n in r: print(calc_distance(base, n), n)/* result :0 신촌역1 신천역2 신쵼2 신천군2 신발2 마곡역*/ N-gramN-gram은 이웃한 N개의 문자를 의미한다.서로 다른 2개의 문장을 N-gram으로 비교해보면 출현하는 단어의 종류와 빈도수, 유사도를 확인할 수 있다.N-gram은 논문 도용, 소스코드간 유사도 등에도 사용할 수 있다. 예를들어 오늘 강남에서 맛있는 스파게티를 먹었다. 강남에서 먹었던 오늘의 스파게티는 맛있었다. 위 문장들을 2글자씩 끊으면123['오늘', '늘 ', ' 강', '강남', '남에', '에서', '서 ', ' 맛', '맛있', '있는', '는 ', ' 스', '스파', '파게', '게티', '티를', '를 ', ' 먹', '먹었', '었다', '다.']['강남', '남에', '에서', '서 ', ' 먹', '먹었', '었던', '던 ', ' 오', '오늘', '늘의', '의 ', ' 스', '스파', '파게', '게티', '티는', '는 ', ' 맛', '맛있', '있었', '었다', '다.'] 이렇게 끊어지게 되는데이 구분된 문장들을 한 항목씩 비교해서 동일한 항목이 있을 때 count를 + 1 하여 총 count / 끊은 문장 배열의 항목 수를 하여 유사도를 구하게 된다. 코드로 알아보자.12345678910111213141516171819202122232425262728293031def ngram(s, num): res = [] slen = len(s) - num + 1 for i in range(slen): ss = s[i:i+num] res.append(ss) return resdef diff_ngram(sa, sb, num): a = ngram(sa, num) b = ngram(sb, num) r = [] cnt = 0 for i in a: for j in b: if i == j: cnt += 1 r.append(i) return cnt / len(a), ra = '오늘 강남에서 맛있는 스파게티를 먹었다.'b = '강남에서 먹었던 오늘의 스파게티는 맛있었다.'r2, word2 = diff_ngram(a, b, 2)print('2-gram:', r2, word2)# result : 2-gram: 0.7619047619047619 ['오늘', '강남', '남에', '에서', '서 ', ' 맛', '맛있', '는 ', ' 스', '스파', '파게', '게티', ' 먹', '먹었', '었다', '다.']r3, word3 = diff_ngram(a, b, 3)print('3-gram:', r3, word3)# result : 3-gram: 0.45 ['강남에', '남에서', '에서 ', ' 맛있', ' 스파', '스파게', '파게티', ' 먹었', '었다.'] 2문장씩 끊었을때의 유사도는 0.76, 3문장씩 끊었을때의 유사도는 0.45로 2문장씩 끊었을 때의 유사도가 더 높았다.N개의 문장을 끊을지는 hyper parameter가 될 것 같다. 유사도를 구할 문장에따라 적절한 값을 입력하면 좋은 결과가 있을 것 같다. 위에 대한 소스코드는https://github.com/suitelab/actual-deeplearning/blob/master/ch6/lev-distance.pyhttps://github.com/suitelab/actual-deeplearning/blob/master/ch6/ngram-test.py에 올려두었다.","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"NLP","slug":"Deep-Learning/NLP","permalink":"http://suitee.me/categories/Deep-Learning/NLP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/tags/Deep-Learning/"},{"name":"NLP","slug":"NLP","permalink":"http://suitee.me/tags/NLP/"}]},{"title":"NLP Basic","slug":"nlp-basic","date":"2018-03-18T21:41:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/03/18/nlp-basic/","link":"","permalink":"http://suitee.me/2018/03/18/nlp-basic/","excerpt":"","text":"Natural Language Processing말과 문장을 이해하고 반응하는데에 목표를 가진다. ex &gt; I like NLP Syntactic 주어 동사 목적어, 문자의 갯수 등 문법적인 것을 이해, 분석한다. Semantic like의 의미가 뭔가 Possitive한 뉘앙스를 가지는가 Nagative한 뉘앙스를 가지는가. Meaning(thinking) 말과 문장이 여러가지 뉘앙스를 가지고 있기때문에 기본적인 지식, 역사 등을 가지고 있어야 하기때문에 현재의 기술 수준으로는 완전한 Understanding까진 힘들다. NLP ApplicationsNLP는 아래의 용도로 사용할 수 있다. 연관검색어 크롤링등을 통해 필요한 정보만 가져오는 것 문서의 주제가 스포츠, 시회 시사문제 인지 분류 어려운 주제인지 쉬운 주제인지 Positive한 뉘앙스인지 Nagative한 뉘앙스인지 분류 강의 주제들 Chatbots NLP vs Deep NLP Word2Vec NN for NLP Recurrent Neural Network Recursive Neural Network Attention and Memory 사용 플랫폼 Api.ai:Conversational UX Platform Wit.ai:Facebook bot NLP processing engine Amazon Echo (Alexa) skill set 강의 동영상 : [Sung Kim 강의 시즌2 Deep NLP][https://youtu.be/O9THzrcCLoA]","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"NLP","slug":"Deep-Learning/NLP","permalink":"http://suitee.me/categories/Deep-Learning/NLP/"}],"tags":[]},{"title":"kaggle Titanic 머신러닝 입문기","slug":"kaggle-titanic","date":"2018-03-18T21:41:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2018/03/18/kaggle-titanic/","link":"","permalink":"http://suitee.me/2018/03/18/kaggle-titanic/","excerpt":"","text":"1import pandas as pd Load Dataset1234train = pd.read_csv(\"data/train.csv\", index_col=\"PassengerId\")print(train.shape)train.head() (891, 11) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S Explore12%matplotlib inlineimport seaborn as sns 1sns.countplot(data=train, x=\"Embarked\", hue=\"Survived\") &lt;matplotlib.axes._subplots.AxesSubplot at 0x23ddebd21d0&gt; 12low_fare = train[train[\"Fare\"] &lt; 100]low_fare.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 1sns.lmplot(data=low_fare, x=\"Age\", y=\"Fare\", hue=\"Survived\", fit_reg=False) &lt;seaborn.axisgrid.FacetGrid at 0x23ddeba74e0&gt; Reload Dataset1234train = pd.read_csv(\"data/train.csv\", index_col=\"PassengerId\")print(train.shape)train.head() (891, 11) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S 1234test = pd.read_csv(\"data/test.csv\", index_col=\"PassengerId\")print(test.shape)test.head() (418, 10) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 892 3 Kelly, Mr. James male 34.5 0 0 330911 7.8292 NaN Q 893 3 Wilkes, Mrs. James (Ellen Needs) female 47.0 1 0 363272 7.0000 NaN S 894 2 Myles, Mr. Thomas Francis male 62.0 0 0 240276 9.6875 NaN Q 895 3 Wirz, Mr. Albert male 27.0 0 0 315154 8.6625 NaN S 896 3 Hirvonen, Mrs. Alexander (Helga E Lindqvist) female 22.0 1 1 3101298 12.2875 NaN S PreprocessingEncode Sex12345train.loc[train[\"Sex\"] == \"male\", \"Sex\"] = 0train.loc[train[\"Sex\"] == \"female\", \"Sex\"] = 1print(train.shape)train.head() (891, 11) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 1 0 3 Braund, Mr. Owen Harris 0 22.0 1 0 A/5 21171 7.2500 NaN S 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... 1 38.0 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen, Miss. Laina 1 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) 1 35.0 1 0 113803 53.1000 C123 S 5 0 3 Allen, Mr. William Henry 0 35.0 0 0 373450 8.0500 NaN S 12345test.loc[test[\"Sex\"] == \"male\", \"Sex\"] = 0test.loc[test[\"Sex\"] == \"female\", \"Sex\"] = 1print(test.shape)test.head() (418, 10) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId 892 3 Kelly, Mr. James 0 34.5 0 0 330911 7.8292 NaN Q 893 3 Wilkes, Mrs. James (Ellen Needs) 1 47.0 1 0 363272 7.0000 NaN S 894 2 Myles, Mr. Thomas Francis 0 62.0 0 0 240276 9.6875 NaN Q 895 3 Wirz, Mr. Albert 0 27.0 0 0 315154 8.6625 NaN S 896 3 Hirvonen, Mrs. Alexander (Helga E Lindqvist) 1 22.0 1 1 3101298 12.2875 NaN S Fill in missing fare1234# 비어있다 =&gt; NaN(Not a Number), nulltest.loc[test[\"Fare\"].isnull(), \"Fare\"] = 0test[test[\"Fare\"].isnull()] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked PassengerId Encode Embarked123456# True == 1, False == 0train[\"Embarked_C\"] = train[\"Embarked\"] == \"C\"train[\"Embarked_S\"] = train[\"Embarked\"] == \"S\"train[\"Embarked_Q\"] = train[\"Embarked\"] == \"Q\"train[[\"Embarked\", \"Embarked_C\", \"Embarked_S\", \"Embarked_Q\"]].head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Embarked Embarked_C Embarked_S Embarked_Q PassengerId 1 S False True False 2 C True False False 3 S False True False 4 S False True False 5 S False True False 12345test[\"Embarked_C\"] = test[\"Embarked\"] == \"C\"test[\"Embarked_S\"] = test[\"Embarked\"] == \"S\"test[\"Embarked_Q\"] = test[\"Embarked\"] == \"Q\"test[[\"Embarked\", \"Embarked_C\", \"Embarked_S\", \"Embarked_Q\"]].head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Embarked Embarked_C Embarked_S Embarked_Q PassengerId 892 Q False False True 893 S False True False 894 Q False False True 895 S False True False 896 S False True False Train1234feature_names = [\"Pclass\", \"Sex\", \"Fare\", \"Embarked_C\", \"Embarked_S\", \"Embarked_Q\"]feature_names [&#39;Pclass&#39;, &#39;Sex&#39;, &#39;Fare&#39;, &#39;Embarked_C&#39;, &#39;Embarked_S&#39;, &#39;Embarked_Q&#39;] 1234X_train = train[feature_names]print(X_train.shape)X_train.head() (891, 6) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Pclass Sex Fare Embarked_C Embarked_S Embarked_Q PassengerId 1 3 0 7.2500 False True False 2 1 1 71.2833 True False False 3 3 1 7.9250 False True False 4 1 1 53.1000 False True False 5 3 0 8.0500 False True False 123456label_name = \"Survived\"y_train = train[label_name]print(y_train.shape)y_train.head() (891,) PassengerId 1 0 2 1 3 1 4 1 5 0 Name: Survived, dtype: int64 1234from sklearn.tree import DecisionTreeClassifiermodel = DecisionTreeClassifier(max_depth=5)model DecisionTreeClassifier(class_weight=None, criterion=&#39;gini&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&#39;best&#39;) 1model.fit(X_train, y_train) DecisionTreeClassifier(class_weight=None, criterion=&#39;gini&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=False, random_state=None, splitter=&#39;best&#39;) Visualize123456789%load_ext gvmagicfrom sklearn.tree import export_graphvizdot_tree = export_graphviz(model, feature_names=feature_names, class_names=[\"Perish\", \"Survived\"], out_file=None)%dotstr dot_tree Predict1234X_test = test[feature_names]print(X_test.shape)X_test.head() (418, 6) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Pclass Sex Fare Embarked_C Embarked_S Embarked_Q PassengerId 892 3 0 7.8292 False False True 893 3 1 7.0000 False True False 894 2 0 9.6875 False False True 895 3 0 8.6625 False True False 896 3 1 12.2875 False True False 1234predictions = model.predict(X_test)print(predictions.shape)predictions[0:10] (418,) array([0, 0, 0, 0, 1, 0, 1, 0, 1, 0], dtype=int64) Submit123456submission = pd.read_csv(\"data/gender_submission.csv\", index_col=\"PassengerId\")submission[\"Survived\"] = predictionsprint(submission.shape)submission.head() (418, 1) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Survived PassengerId 892 0 893 0 894 0 895 0 896 1 1submission.to_csv(\"data/decision-tree.csv\") 결과는 0.78947로 나름 만족스럽게 나왔다.","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"Kaggle","slug":"Deep-Learning/Kaggle","permalink":"http://suitee.me/categories/Deep-Learning/Kaggle/"}],"tags":[]},{"title":"딥러닝 공부 커리큘럼","slug":"DeepLearning-Study-Road","date":"2018-03-13T15:00:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2018/03/13/DeepLearning-Study-Road/","link":"","permalink":"http://suitee.me/2018/03/13/DeepLearning-Study-Road/","excerpt":"","text":"스티브 워즈니악 옹은 “All my great stuff, I learned outside of school”이라 했다. 누가 가르쳐 주는 것을 그대로 배우는 것 보다, 스스로 여기저기 헤매 보면서 이것저것 생각 해 보고 만들어 보는 것이 가장 좋다고 생각한다. 나는 그렇게 헤매면서 여기까지 왔고, 앞으로도 열심히 즐겁게 헤매고 다닐것 같다. 하지만 헤매고 있을 시간이 없는 경우, 또는 헤매는 것이 즐겁지 않고 짜증만 나는 경우에는 먼저 간 사람이 찾아둔 길을 따라가는 것이 좋겠다. 내가 찾아둔 지름길을 공유 한다. 가장 먼저 할 일은 코세라의 앤드류 응 교수님 강의를 듣는 것이다.강의 동영상은 유튜브에도 모두 공개되어 있다. 하지만 꼭 코세라에서 들으면서 옥타브로 숙제를 해 봐야 한다. 무료로도 들을 수 있지만, 79달러를 내고 들으면 강의 내용이 머리 속에 더 잘 들어 오게 된다. 진짜다. 코세라의 앤드류 응 교수님의 머신러닝 강의: https://www.coursera.org/certificate/machine-learning 다른 스타일의 강의들 모음: https://www.facebook.com/dgtgrade/posts/1145680742157457 한국어 강의를 원하면 김성훈 교수님의 모두를 위한 딥러닝 강의를 들으면 된다. 모두를 위한 딥러닝: https://youtu.be/BS6O0zOGX4E?list=PLlMkM4tgfjnLSOjrEJN31gZATbcj_MpUm 혹시 그냥 엄청나게 쉬운 강의부터 시작하고 싶으면 휴먼러닝을 들으면 된다. 휴먼러닝: https://youtu.be/CRaKdnk2W9c?list=PLefQdA1SdkhtRUuN_D3PdxaR2XTGQw8Ph 1번의 강의를 듣다 보면 금새 선형회귀와 신경망의 기초에 대해서 알게 된다. 이때 Universal Approximation Theorem에 대해서 공부한 뒤 간단한 신경망을 직접 Python+Numpy로 구현해 봐야 한다. 참고 글: https://www.facebook.com/groups/TensorFlowKR/permalink/332680743739657 꼭 Python으로 해야 하는 건가? 아니다. 그럴리가 없지 않은가. 하지만 내가 추천하는 지름길은 Python이다. 그게 대세이기 때문이다. 대세가 꼭 나나 너에게 맞는 것은 아니지만 대세를 따르면 편하다. 이글은 어디까지나 지름길에 대한 글이지 나의 길이나 너의 길에 대한 글이 아니다. Python이 생소하더라고 괜찮다. Python은 초기 진입 장벽이 매우 낮은 언어이므로 겁먹을 필요 없다. 처음에는 Numpy의 신택스가 좀 어려워 보일 수 있는데 익숙해지고 나면 Numpy 없으면 못 살거 같은 느낌이 든다. Python+Numpy+기타 등등의 설치의 지름길은 Anaconda다. IDE는 나는 PyCharm을 사용하고 있다. 원래 vi를 사랑하고 (진짜) 지금도 사랑하지만 PyCharm 써보고 나니 앞으로 적어도 Python 코딩은 vi에서는 못 할 것 같다. 개발 환경 준비에 대한 더 상세한 내용은 아래의 영상을 참고하면 된다. 머신러닝 개발환경 준비: https://youtu.be/pMkwjXFZdH4?list=PLefQdA1SdkhtRUuN_D3PdxaR2XTGQw8Ph 신경망과 Python과 Numpy가 어느 정도 익숙해지고 나면 드디어 TensorFlow를 사용해 볼 때다.마찬가지로 꼭 TensorFlow여야 하는가? 하는 질문이 있을 수 있다. 아니다. 하지만 TF가 대세다. 앞에서 지도학습 문제를 풀어봤으므로 이제는 비지도 학습 문제를 풀어볼 때가 되었다. 비지도 학습이란 것을 이해할 수 있는 가장 쉬운 방법은 Auto Encoder를 직접 만들어 보는 것이다. 그리고 데이터는 머신러닝의 헬로월드인 MNIST를 사용하면 된다. 즉, 목표는 MNIST AE를 만드는 것이다. 아직은 CNN에 대해서 모르므로 괜히 어렵게 CNN으로 하지 말고 FC로만 해도 된다. MNIST는 너무 쉬운 문제라서 FC로 해도 잘 된다. TensorFlow가 너무 빨리 업그레이드 되고, 스펙도 많이 변하고 있어서, 겨우 몆주전에 올라온 글의 정보가 현재 상황과 맞지 않거나, 예제 코드가 지금은 잘 안 돌아가기도 하는데 그 점 주의해야 한다. 웹에서 구한 예제 코드가 바로 안 돌아간다고 겁먹을 필요 없다. 대부분 아주 살짝씩만 수정해 주면 돌아갈거다. 그리고 윈도우에서도 TensorFlow 잘 돌아간다. GPU도 잘 이용할 수 있다. 더 심각하게 머신러닝을 열심히 잘 해 보려면 결국 리눅스로 가는게 이래저래 편하긴 하다. TF외의 라이브러리들이 윈도우에서 잘 안 되는 경우들이 간혹 있다. 하지만 일단 이 글에서 다루는 지름길의 범위 내에서는 그냥 윈도우에서 해도 문제 없다. 여기까지 왔으면 딥러닝이 어떤 것인지 대강 감은 잡힌다. 이제부터 신나게 이것저것 공부하고 만들어 보고 하면 된다. 그런데 역시 시간을 아끼고 싶으면 추가로 아래글도 읽어 보고 길을 떠난다. 참고 글: https://www.facebook.com/dgtgrade/posts/1328790023846527 이제부터는 훨씬 더 큰 규모의 신경망을 다뤄야 하고, 그러려면 ReLU와 친해져야 한다.ReLU에 대해서 진지하게 고민해 볼 필요가 있다. ReLU가 왜 비선형인지? 뉴런에서 비선형 처리 부분이 없어지면 어떻게 되는 것인지? 왜 Sigmoid 보다 ReLU가 좋은 것인지? 등에 대해서 고민해 본다. 참고 글: https://www.facebook.com/dgtgrade/posts/1337481972977332 추가로 Bias가 없으면 어떻게 되는지 등 신경망 전체의 수학적 의미에 대해서 다각도로 고민해 본다. 머리속에서만 고민해 보지 말고 코딩을 해 보면 좋다. 여기까지 왔으면 이런저런 실험 코딩은 어렵지 않을 거다. 지금까지 해 본 것보다 훨신 큰 규모의 신경망을 학습 시키기 위해서는 GPU가 필요하다.CPU로 할때 보다 10배~50배 정도 빠르게 학습 시킬 수 있다. CPU로 하면 뭐 하나 돌려보고 드라마 하나 보고 자리에 돌아와 보면 에러 떠 있다. 같은 것을 GPU로 돌려 보면 차한잔 할 새도 없이 에러가 떠 있을 것다. CPU로 하면 돌려 놓고 다음 날 아침이 되어서야 결과를 볼 수 있는 경우가 꽤 있다. 죽는다. 답답해서. GTX1080이 필요하다. (상세설명 생략하고) 대세다. 문제는 가격인데 대강 100만원 정도 한다. 그리고 1개 보다 2개가 좋다. 학습을 2배로 빨리 할 수 있기 때문만은 아니다. 1개 밖에 없는 경우에는 하나 학습 돌려 놓은 뒤로 추가로 개발 진행한 내용을 잠깐만 실험 삼아 돌려 보는 것을 할 수 없기 때문이다. 아주 할 수 없지는 않을 것 같은데 아무튼 쉽지 않다. 그런데 이 녀석을 2개나 꼽으려면 메인보드와 파워도 좋아야 한다. 그리고 GTX1080은 딥러닝 용으로만 사용하고 디스플레이 용으로는 메인보드의 내장 그래픽 카드를 사용하는 것이 여러모로 편하므로 내장 그래픽 카드도 쓸만해야 한다. 예를 들어 4K 모니터를 사용 중이라면 내장 그래픽카드가 4K를 지원해야 하겠다. 이렇게 해서 준비하면 본체에만 대략 총 300만원 정도의 투자가 필요하다. 학교나 회사 등의 조직에 속한 경우에는 조직장을 잘(…) 설득하여 구매하면 된다. 개인의 경우에는… 그렇다. 이런 투자를 쉽게 하기는 어려울 거다. 문제다. 조직이든 개인이든 당장 이 정도의 투자가 어려운 경우에는 AWS나 Google Cloud 등을 이용하는 것도 방법이겠다. 아무래도 개발은 로컬에서 하는 것이 편할테니 개발은 로컬에서 하고 CPU로만 돌려 본 후에 본격적인 학습은 클라우드에서 GPU로 돌리면 되겠다. 코드 변경은 필요 없고, 클라우드 사용료는 시간당 몇백원 수준이라고 한다. 나는 클라우드에서는 열심히 해 본 적이 없어서 더 상세한 안내는 못 한다. 이제 드디어 개와 고양이를 분류해 볼 수 있는 때가 왔다. Convolutional Neural Network를 사용하면 된다.CNN을 공부하고, CNN을 이용해서 무언가 재밌는 걸 만들어 본다. 이렇게 딥러닝이 핫하게 된 것도 CNN 때문이다. CNN으로는 많은 일을 해 볼 수 있다. 참고 글: https://www.facebook.com/groups/TensorFlowKR/permalink/341049512902780 용기 있는 사람들은 이쯤에서 GAN을 해 봐도 된다. GAN은 정말… 신기한 녀석이다. Batch Normalization을 적용해야 한다.그런데 막상 이렇게 큰 신경망을 다루려다 보면 이런 저런 이유로 잘 안 될거다. 그러면 이제 Batch Normalization을 적용해야 한다. BN은 감동이다. 앞에서 얘기한 이런저런 문제들 중 기초적인 문제들을 한방에 해결해 준다. 참고 글: https://www.facebook.com/dgtgrade/posts/1337790532946476 이제 강화학습을 공부해 볼 수 있다. 알파고는 바로 이 강화학습으로 만들어졌다. 강화학습은 OpenAI Gym에서 진행하는 것이 좋다.이쯤 되면 더 이상 이런 단편적인 내용의 글이 필요할 것으로 생각하지 않는다. 각자의 길을 간다.다만 남들이 고민해 둔 거 그대로 공부만 하려 하지 말고, 또 공부 많이 한 다음 뭔가 만들어 보려 하지 말고, 간단한 뭔가라도 실제로 만들어 보면서 공부 하기를 추천한다. 물론 대부분의 경우 찾아보면 분명히 남들이 이미 더 잘 정리 하고 잘 만들어 둔 것이 있을 거다. 하지만 본인이 직접 만들어 보면서 1) 문제를 발견 하고 2) 해결책을 고민해 보고 하는 것이 남들이 정리해 둔 문제와 해답을 먼저 보는 것 보다 훨씬 공부가 많이 된다. 특히 답이 아니라 문제가 뭔지를 스스로 발견하는 과정은 매우 중요하다. 출처: http://ohnu.tistory.com/entry/딥러닝-공부방법","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"Basic","slug":"Deep-Learning/Basic","permalink":"http://suitee.me/categories/Deep-Learning/Basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/tags/Deep-Learning/"}]},{"title":"딥러닝 강의 lec 03","slug":"lab03-Linear-Regression-Cost-Min","date":"2017-10-18T15:00:00.000Z","updated":"2019-02-14T02:51:04.669Z","comments":true,"path":"2017/10/18/lab03-Linear-Regression-Cost-Min/","link":"","permalink":"http://suitee.me/2017/10/18/lab03-Linear-Regression-Cost-Min/","excerpt":"","text":"ML lab 03 - Linear Regression의 cost 최소화의 TensorFlow 구현 (new)12import tensorflow as tfimport matplotlib.pyplot as plt Variables Initialize1234X = [1, 2, 3]Y = [1, 2, 3]W = tf.placeholder(tf.float32) Hypothesis12#hypothesis = Wxhypothesis = X * W 12# cost = avg(sum(H - y)2)cost = tf.reduce_mean(tf.square(hypothesis - Y)) Session start12sess = tf.Session()sess.run(tf.global_variables_initializer()) 1234567W_val = []cost_val = []for i in range(-30, 50): feed_W = i * 0.1 curr_cost, curr_W = sess.run([cost, W], feed_dict=&#123;W: feed_W&#125;) W_val.append(curr_W) cost_val.append(curr_cost) Visualize12plt.plot(W_val, cost_val)plt.show() Gradient descent우리의 cost 같이 밥그릇 모양의 그래프일 때 사용하는 알고리즘가장 안쪽의 (1,0)의 점을 찾는 것이 목표 미분 : 한 점의 기울기를 나타냄↗ 모양의 경우 +↘ 모양의 경우 - 위와 같은 그래프에서 (4, 50)의 경우 ↗ 모양이므로 +W가 1이 되기 위해선 -로 움직여야함 위와 같은 그래프에서 (-2, 40)의 경우 ↘ 모양이므로 -W가 1이 되기 위해선 +로 움직여야함 수식으로 구현 시 cost(W) = \\frac{1}{m}\\sum_{i=1}^{m}(Wx^{(i)} - y^{(i)})^{2}미분한 결과 W := W - a\\frac{1}{m}\\sum_{i=1}^{m}(Wx^{(i)} - y^{(i)})x^{(i)}1234learning_rate = 0.1gradient = tf.reduce_mean((W * X - Y) *X)descent = W - learning_rate * gradientupdate = W.assign(descent) Gradient descent 적용123import tensorflow as tfx_data = [1, 2, 3]y_data = [1, 2, 3] 123W = tf.Variable(tf.random_normal([1]), name = 'weight')X = tf.placeholder(tf.float32)Y = tf.placeholder(tf.float32) 1hypothesis = X * W 1cost = tf.reduce_sum(tf.square(hypothesis - Y)) 1234learning_rate = 0.1gradient = tf.reduce_mean((W * X - Y) * X)descent = W - learning_rate * gradientupdate = W.assign(descent) 123456sess = tf.Session()sess.run(tf.global_variables_initializer())for step in range(21): sess.run(update, feed_dict=&#123;X: x_data, Y: y_data&#125;) print(step, sess.run(cost, feed_dict=&#123;X: x_data, Y:y_data&#125;), sess.run(W)) 0 4.66668 [ 0.42264879] 1 1.32741 [ 0.69207931] 2 0.377575 [ 0.83577561] 3 0.107399 [ 0.91241366] 4 0.0305491 [ 0.9532873] 5 0.00868952 [ 0.97508657] 6 0.00247167 [ 0.98671287] 7 0.000703047 [ 0.99291354] 8 0.000199983 [ 0.99622053] 9 5.68846e-05 [ 0.99798429] 10 1.61796e-05 [ 0.99892497] 11 4.60181e-06 [ 0.99942666] 12 1.30917e-06 [ 0.99969423] 13 3.72323e-07 [ 0.99983692] 14 1.05845e-07 [ 0.99991304] 15 3.01388e-08 [ 0.99995363] 16 8.55728e-09 [ 0.99997526] 17 2.43397e-09 [ 0.99998683] 18 6.87535e-10 [ 0.99999297] 19 1.96071e-10 [ 0.99999624] 20 5.89608e-11 [ 0.99999797] Minimize : Gradient descent12optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.1)train = optimizer.minimize(cost) 123import tensorflow as tfX = [1, 2, 3]Y = [1, 2, 3] 12#W = tf.Variable(5.0)W = tf.Variable(-45.0) 1hypothesis = X * W 1cost = tf.reduce_mean(tf.square(hypothesis - Y)) 12optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.1)train = optimizer.minimize(cost) 123456sess = tf.Session()sess.run(tf.global_variables_initializer())for step in range(10): print(step, sess.run(W)) sess.run(train) 0 5.0 1 5.0 2 5.0 3 5.0 4 5.0 5 5.0 6 5.0 7 5.0 8 5.0 9 5.0 Optional: compute_gradient and apply_gradientGradientDescentOptimizer를 새로운 식으로 커스텀마이징 하고싶을 때 방법 123import tensorflow as tfX = [1, 2, 3]Y = [1, 2, 3] 1W = tf.Variable(5.0) 1hypothesis = X * W 1gradient = tf.reduce_mean((W * X - Y) * X) * 2 12cost = tf.reduce_mean(tf.square(hypothesis - Y))optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.1) 12gvs = optimizer.compute_gradients(cost)apply_gradients = optimizer.apply_gradients(gvs) 123456sess = tf.Session()sess.run(tf.global_variables_initializer())for step in range(10): print(step, sess.run([gradient, W])) sess.run(apply_gradients) 0 [37.333332, 5.0] 1 [2.4888866, 1.2666664] 2 [0.16592591, 1.0177778] 3 [0.011061668, 1.0011852] 4 [0.00073742867, 1.000079] 5 [4.895528e-05, 1.0000052] 6 [3.0994415e-06, 1.0000004] 7 [0.0, 1.0] 8 [0.0, 1.0] 9 [0.0, 1.0]","categories":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/categories/Deep-Learning/"},{"name":"Basic","slug":"Deep-Learning/Basic","permalink":"http://suitee.me/categories/Deep-Learning/Basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://suitee.me/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"http://suitee.me/tags/Jupyter/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://suitee.me/tags/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://suitee.me/tags/Machine-Learning/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://suitee.me/tags/tensorflow/"}]},{"title":"Dynamic Programming","slug":"Dynamic-Programming","date":"2017-09-13T15:00:00.000Z","updated":"2019-02-14T02:51:04.665Z","comments":true,"path":"2017/09/13/Dynamic-Programming/","link":"","permalink":"http://suitee.me/2017/09/13/Dynamic-Programming/","excerpt":"","text":"참고 : 백준 - 다이나믹 프로그래밍 시작하기 Dynamic Programming 큰 문제를 작은 문제로 나눠서 푸는 알고리즘 Overlapping Subproblem Optimal Substructure Overlapping Subproblem 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다. 문제를 작은 문제로 쪼갤 수 있다. 문제의 정답을 작은 문제의 정답에서 구할 수 있다. 예시 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면대전에서 부산을 가는 가장빠른 길은 대구를 거쳐야 한다. Optimal Substructure 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다. 문제를 작은 문제로 쪼갤 수 있다. 작성중","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://suitee.me/categories/Algorithm/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://suitee.me/tags/Dynamic-Programming/"},{"name":"동적계획법","slug":"동적계획법","permalink":"http://suitee.me/tags/동적계획법/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://suitee.me/tags/알고리즘/"},{"name":"Bottom Up","slug":"Bottom-Up","permalink":"http://suitee.me/tags/Bottom-Up/"},{"name":"Top Down","slug":"Top-Down","permalink":"http://suitee.me/tags/Top-Down/"},{"name":"백준","slug":"백준","permalink":"http://suitee.me/tags/백준/"}]}]}